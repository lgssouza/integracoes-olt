from flask import Flask, request, jsonify
import json
import time
import sys
import socket

class Fiberhome():
    #Método que interpreta a resposta recebida e devolve a mensagem para ser enviada via json
    @staticmethod
    def retornaResposta(resposta):
        if "resource does not exist" in resposta:
            return "O recurso não existe"
        elif "the alarm does not exist" in resposta:
            return "O alarme não existe"
        elif "missing parameter" in resposta:
            return "Ausência de parâmetro"
        elif "invalid parameter format" in resposta:
            return "Formato de parâmetro inválido"
        elif "input parameter error" in resposta:
            return "Parâmetro de entrada inválido"
        elif "device may not support this operation" in resposta:
            return "O dispositivo pode não suportar esta operação"
        elif "device operation failed" in resposta:
            return "A operação no dispositivo falhou"
        elif "device is busy" in resposta:
            return "O dispositivo está ocupado"
        elif "EMS may not support this operation" in resposta:
            return "O EMS pode não suportar esta operação"
        elif "EMS operation failed" in resposta:
            return "Falha na operação do EMS"
        elif "EMS exception happens" in resposta:
            return "Aconteceu uma exceção no EMS"
        elif "user is busy" in resposta:
            return "O usuário está ocupado"
        elif "user is testing" in resposta:
            return "O usuário está em teste"
        elif "test module is busy" in resposta:
            return "O módulo de teste está ocupado"
        elif "resource already exist" in resposta:
            return "O nome ja existe"
        elif "No error" in resposta:
            return "Sucesso"
        else:
            return "Erro"
    #Método que realzia a conexao via TL1
    def conexao(ip_servidor_tl1, porta_servidor_tl1, usuario_anm, senha_anm):
        print("entrou no metodo conexao")
        global conexao
        #AF_INET informa que será usado o  procolo TCP
        #SOCK_STREAM informa que será usado IPV4 na conexão
        conexao = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        conexao.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        tmp = conexao.connect_ex((ip_servidor_tl1, porta_servidor_tl1))
        if tmp != 0:
            print("Pau no cu do IXC")
        else:
            print("Deu bom")
        #Usuário e senha do anm/unm
        script_conexao = 'LOGIN:::CTAG::UN='+usuario_anm+',PWD='+senha_anm+';'
        script_conexao = script_conexao.encode('utf-8')
        #script_handshake = 'SHAKEHAND:::CTAG::;'
        conexao.send(script_conexao)
        #conexao.sendall(script_handshake.encode('utf-8'))
        time.sleep(2

    @staticmethod
    def logout():
        print("Entrou no logout")
        script_logout = 'LOGOUT:::CTAG::;'
        script_logout = script_logout.encode('utf-8')
        conexao.send(script_logout)
        print("enviar")
        conexao.shutdown(1)
        conexao.close()
        print("saiu do logout")
        return

    def buscaOnu(ip_olt):
        #Recebe as informações em json de conexão via POST
        #dados_olt          = request.json
        #conexao()
        #cria os arrays para receber as informações da ONUs
        resposta    = [] 
        #ip da OLT recebido via POST
        oltip   = ip_olt
        #Padrão para buscar em todas as PONs
        script_busca_onu = 'LST-UNREGONU::OLTID='+oltip+',PONID=NA:CTAG::;'
        #script_busca_onu = script_busca_onu.encode('utf-8')
        #Envia os dados via sandall, metodo do socket, todo codificado em uma cadeia de strings em UTF-8
        try:
            conexao.settimeout(15)
            print(conexao.gettimeout())
            conexao.sendall(script_busca_onu.encode('utf-8'))
            time.sleep(2)
        except:
            print("entrou no except")
            Fiberhome.logout()
        #Recebe os dados retornado
        data = conexao.recv(5000)
        #decodifica esses dados de bytes para uma cadeia de strings UTF-8
        data = data.decode("utf-8")
        data = data.replace(" ","")
        #Percorre todas linhas de retorno, separando cada uma delas como elementos de uma lista onde existe quebra de linha
        for linha in data.split("\n"):
            linha = linha.replace("\t"," ")
            linha = linha.replace("\r","")
            #separada cada elementos da linha colocando como elemento de uma lista
            elementos = linha.split(" ")
            #Caso a quantidade de elementos seja maior que 7, é a linha que contem as informações da(s) onu(s)
            if len(elementos) > 7 and not(elementos[0] == "SLOTNO"):
                dados_onu = {
                    "SLOT": elementos[0],
                    "PON": elementos[1],
                    "MAC": elementos[2][0:12],
                    "TIPO_ONU": elementos[7]
                }
                #insere o conjunto dentro do array de resposta
                #Dessa forma, caso tenha mais de uma ONU, todas serão enviadas via json
                resposta.append(dados_onu)
        #Convertendo um dicionário criado em um json
        data_json = json.dumps(resposta)  
        #conexao.shutdown(socket.SHUT_RDWR)
        #conexao.close()
        return data_json

    def autorizaOnu(ip_olt, numero_pon, mac_onu, tipo_onu, nome_cliente, vlan):
        resposta    = [] 
        script_liberacao_onu = 'ADD-ONU::OLTID='+ip_olt+',PONID=NA-NA-'+numero_pon+':CTAG::AUTHTYPE=MAC,ONUID='+mac_onu+',NAME='+nome_cliente+',ONUTYPE='+tipo_onu+';CFG-LANPORTVLAN::OLTID='+ip_olt+',PONID=NA-9-'+numero_pon+',ONUIDTYPE=MAC,ONUID='+mac_onu+',ONUPORT=NA-NA-NA-1:CTAG::CVLAN='+vlan+';'
        #script_liberacao_onu = script_liberacao_onu.encode('utf-8')
        #Envia os dados via sendall, metodo do socket, todo codificado em uma cadeia de strings em UTF-8
        try:
            conexao.settimeout(15)
            print(conexao.gettimeout())
            conexao.sendall(script_liberacao_onu.encode('utf-8'))
            time.sleep(2)
        except:
            print("entrou no except")
            Fiberhome.logout()
        #Recebe os dados retornado
        data = conexao.recv(1024)
        #decodifica esses dados de bytes para uma cadeia de strings UTF-8
        data = data.decode("utf-8")
        #data = data.replace(" ","")
        for linha in data.split("\n"):
            #indentifica dentro da linha, qual contem a resposta da requisição (ENDESC)
            if "ENDESC" in linha:
                #Quebra o conteudo da linha e faz com que cada parte separada por igual seja um elemento da lista
                elemento = linha.split("=")
                resp = Fiberhome.retornaResposta(elemento[2])
                break
        #Percorre todas linhas de retorno, separando cada uma delas como elementos de uma lista onde existe quebra de linha
        mensagem = {
            "msg": resp
        }  
        resposta.append(mensagem)
        #Convertendo um dicionário criado em um json
        data_json = json.dumps(resposta)  
        #conexao.shutdown(socket.SHUT_RDWR)
        #conexao.close()
        return data_json

    def desautorizaOnu(ip_olt, mac_onu, slot_pon):
        resposta    = [] 
        script_exclusao_onu = 'DEL-ONU::OLTID='+ip_olt+',PONID=NA-NA-'+slot_pon+':CTAG::ONUIDTYPE=MAC,ONUID='+mac_onu+';'
        #script_exclusao_onu = script_exclusao_onu.encode('utf-8')
        #Envia os dados via sendall, metodo do socket, todo codificado em uma cadeia de strings em UTF-8
        try:
            conexao.settimeout(15)
            print(conexao.gettimeout())
            conexao.sendall(script_exclusao_onu.encode('utf-8'))
            time.sleep(2)
        except:
            print("entrou no except")
            Fiberhome.logout()
        #Recebe os dados retornado
        print("Deu bom desautorizaOnu")
        data = conexao.recv(1024)
        #decodifica esses dados de bytes para uma cadeia de strings UTF-8
        data = data.decode("utf-8")
        for linha in data.split("\n"):
            #indentifica dentro da linha, qual contem a resposta da requisição (ENDESC)
            if "ENDESC" in linha:
                #Quebra o conteudo da linha e faz com que cada parte separada por igual(=) seja um elemento da lista
                elemento = linha.split("=")
                #a posição 2 da lista de elementos é a resposta
                #a resposta é passa para a função retornaResposta, que verifica a mensagem, e retorna a resposta que será enviada no json
                resp = Fiberhome.retornaResposta(elemento[2])
        #Percorre todas linhas de retorno, separando cada uma delas como elementos de uma lista onde existe quebra de linha
        mensagem = {
            "msg": resp
        }
        resposta.append(mensagem)
        #Convertendo um dicionário criado em um json
        data_json = json.dumps(resposta)  
        #conexao.shutdown(socket.SHUT_RDWR)
        #conexao.close()
        Fiberhome.logout()
        return data_json

    def consultaSinalOnu(ip_olt, mac_onu, slot_pon):
        resposta    = [] 
        script_consulta_sinal_onu = 'LST-OMDDM::OLTID='+ip_olt+',PONID=NA-NA-'+slot_pon+',ONUIDTYPE=MAC,ONUID='+mac_onu+':CTAG::;'
        #script_consulta_sinal_onu = script_consulta_sinal_onu.encode('utf-8')
        #Envia os dados via sendall, metodo do socket, todo codificado em uma cadeia de strings em UTF-8
        try:
            conexao.settimeout(15)
            print(conexao.gettimeout())
            conexao.sendall(script_consulta_sinal_onu.encode('utf-8'))
        except:
            print("entrou no except")
            Fiberhome.logout()
        #Recebe os dados retornado
        #Recebe os dados retornado
        time.sleep(2)
        print("Deu bom consultaSinalOnu")
        data = conexao.recv(1024)
        #decodifica data = conexao.recv(1024)esses dados de bytes para uma cadeia de strings UTF-8
        data = data.decode("utf-8")
        data = data.replace(" ","")
        #Percorre todas linhas de retorno, separando cada uma delas como elementos de uma lista onde existe quebra de linha
        for linha in data.split("\n"):
            linha = linha.replace("\t"," ")
            linha = linha.replace("\r","")
            #separada cada elementos da linha colocando como elemento de uma lista
            elementos = linha.split(" ")
            #Caso a quantidade de elementos seja maior que 7, é a linha que contem as informações da onu
            if len(elementos) > 7 and not(elementos[0] == "ONUID"):
                dados_onu = {
                    "SINAL": elementos[1]
                }
                #insere o conjunto dentro do array de resposta
                #Dessa forma, caso tenha mais de uma ONU, todas serão enviadas via json
                resposta.append(dados_onu)
        #Convertendo um dicionário criado em um json
        data_json = json.dumps(resposta)
        #conexao.shutdown(socket.SHUT_RDWR)
        #conexao.close()
        Fiberhome.logout()
        return data_json
